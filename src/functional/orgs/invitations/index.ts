import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IApiOrgsInvitations } from "../../../structures/IApiOrgsInvitations";
import { organization_minus_invitation } from "../../../structures/organization_minus_invitation";
import { body } from "../../../structures/body";
export * as teams from "./teams";
/**
 * List pending organization invitations.
 * The return hash contains a `role` field which refers to the Organization
 * Invitation role and will be one of the following values: `direct_member`, `admin`,
 * `billing_manager`, or `hiring_manager`. If the invitee is not a GitHub
 * member, the `login` field in the return hash will be `null`.
 *
 * @tag orgs
 * @path orgs/:org/invitations
 * @nestia Generated by Nestia - https://github.com/samchon/nestia
 */
export async function getByOrg(
  connection: IConnection<getByOrg.Headers>,
  org: string,
  query: getByOrg.Query,
): Promise<getByOrg.Output> {
  return !!connection.simulate
    ? getByOrg.simulate(connection, org, query)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getByOrg.METADATA,
          path: getByOrg.path(org, query),
          status: null,
        },
      );
}
export namespace getByOrg {
  export type Headers = IApiOrgsInvitations.GetHeader;
  export type Query = IApiOrgsInvitations.GetQuery;
  export type Output = organization_minus_invitation[];

  export const METADATA = {
    method: "GET",
    path: "/orgs/:org/invitations",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (org: string, query: getByOrg.Query) => {
    const variables: URLSearchParams = new URLSearchParams();
    for (const [key, value] of Object.entries(query as any))
      if (undefined === value) continue;
      else if (Array.isArray(value))
        value.forEach((elem: any) => variables.append(key, String(elem)));
      else variables.set(key, String(value));
    const location: string = `/orgs/${encodeURIComponent(org ?? "null")}/invitations`;
    return 0 === variables.size
      ? location
      : `${location}?${variables.toString()}`;
  };
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): organization_minus_invitation[] =>
    typia.random<organization_minus_invitation[]>(g);
  export const simulate = (
    connection: IConnection<getByOrg.Headers>,
    org: string,
    query: getByOrg.Query,
  ): Output => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getByOrg.path(org, query),
      contentType: "application/json",
    });
    try {
      assert.param("org")(() => typia.assert(org));
      assert.query(() => typia.assert(query));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}
/**
 * Create an organization invitation.
 * Invite people to an organization by using their GitHub user ID or their email address. In order to create invitations in an organization, the authenticated user must be an organization owner.
 *
 * This endpoint triggers [notifications](https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. For more information, see "[Rate limits for the API](https://docs.github.com/rest/using-the-rest-api/rate-limits-for-the-rest-api#about-secondary-rate-limits)"
 * and "[Best practices for using the REST API](https://docs.github.com/rest/guides/best-practices-for-using-the-rest-api)."
 *
 * @tag orgs
 * @path orgs/:org/invitations
 * @nestia Generated by Nestia - https://github.com/samchon/nestia
 */
export async function postByOrg(
  connection: IConnection<postByOrg.Headers>,
  org: string,
  body: postByOrg.Input,
): Promise<postByOrg.Output> {
  return !!connection.simulate
    ? postByOrg.simulate(connection, org, body)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...postByOrg.METADATA,
          path: postByOrg.path(org),
          status: null,
        },
        body,
      );
}
export namespace postByOrg {
  export type Headers = IApiOrgsInvitations.PostHeader;
  export type Input = body;
  export type Output = organization_minus_invitation;

  export const METADATA = {
    method: "POST",
    path: "/orgs/:org/invitations",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (org: string) =>
    `/orgs/${encodeURIComponent(org ?? "null")}/invitations`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): organization_minus_invitation =>
    typia.random<organization_minus_invitation>(g);
  export const simulate = (
    connection: IConnection<postByOrg.Headers>,
    org: string,
    body: postByOrg.Input,
  ): Output => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: postByOrg.path(org),
      contentType: "application/json",
    });
    try {
      assert.param("org")(() => typia.assert(org));
      assert.body(() => typia.assert(body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}
/**
 * Cancel an organization invitation. In order to cancel an organization invitation, the authenticated user must be an organization owner.
 *
 * This endpoint triggers [notifications](https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications).
 *
 * @tag orgs
 * @path orgs/:org/invitations/:invitation_id
 * @nestia Generated by Nestia - https://github.com/samchon/nestia
 */
export async function eraseByOrgAndInvitation_id(
  connection: IConnection<eraseByOrgAndInvitation_id.Headers>,
  org: string,
  invitation_id: string,
): Promise<void> {
  return !!connection.simulate
    ? eraseByOrgAndInvitation_id.simulate(connection, org, invitation_id)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseByOrgAndInvitation_id.METADATA,
          path: eraseByOrgAndInvitation_id.path(org, invitation_id),
          status: null,
        },
      );
}
export namespace eraseByOrgAndInvitation_id {
  export type Headers = IApiOrgsInvitations.DeleteHeader;

  export const METADATA = {
    method: "DELETE",
    path: "/orgs/:org/invitations/:invitation_id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (org: string, invitation_id: string) =>
    `/orgs/${encodeURIComponent(org ?? "null")}/invitations/${encodeURIComponent(invitation_id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): void =>
    typia.random<void>(g);
  export const simulate = (
    connection: IConnection<eraseByOrgAndInvitation_id.Headers>,
    org: string,
    invitation_id: string,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseByOrgAndInvitation_id.path(org, invitation_id),
      contentType: "application/json",
    });
    try {
      assert.param("org")(() => typia.assert(org));
      assert.param("invitation_id")(() => typia.assert(invitation_id));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}
