import { HttpError, IConnection } from "@nestia/fetcher";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia from "typia";

import { IApiOrgsTeamsRepos } from "../../../../structures/IApiOrgsTeamsRepos";
import { body } from "../../../../structures/body";
import { minimal_minus_repository } from "../../../../structures/minimal_minus_repository";
import { team_minus_repository } from "../../../../structures/team_minus_repository";

/**
 * List team repositories.
 * Lists a team's repositories visible to the authenticated user.
 *
 * > [!NOTE]
 * > You can also specify a team by `org_id` and `team_id` using the route `GET /organizations/{org_id}/team/{team_id}/repos`.
 *
 * @tag teams
 * @path orgs/:org/teams/:team_slug/repos
 * @nestia Generated by Nestia - https://github.com/samchon/nestia
 */
export async function getByOrgAndTeam_slug(
  connection: IConnection<getByOrgAndTeam_slug.Headers>,
  org: string,
  team_slug: string,
): Promise<getByOrgAndTeam_slug.Output> {
  return !!connection.simulate
    ? getByOrgAndTeam_slug.simulate(connection, org, team_slug)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getByOrgAndTeam_slug.METADATA,
          path: getByOrgAndTeam_slug.path(org, team_slug),
          status: null,
        },
      );
}
export namespace getByOrgAndTeam_slug {
  export type Headers = IApiOrgsTeamsRepos.GetHeader;
  export type Output = minimal_minus_repository[];

  export const METADATA = {
    method: "GET",
    path: "/orgs/:org/teams/:team_slug/repos",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (org: string, team_slug: string) =>
    `/orgs/${encodeURIComponent(org ?? "null")}/teams/${encodeURIComponent(team_slug ?? "null")}/repos`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): minimal_minus_repository[] => typia.random<minimal_minus_repository[]>(g);
  export const simulate = (
    connection: IConnection<getByOrgAndTeam_slug.Headers>,
    org: string,
    team_slug: string,
  ): Output => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getByOrgAndTeam_slug.path(org, team_slug),
      contentType: "application/json",
    });
    try {
      assert.param("org")(() => typia.assert(org));
      assert.param("team_slug")(() => typia.assert(team_slug));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}
/**
 * Check team permissions for a repository.
 * Checks whether a team has `admin`, `push`, `maintain`, `triage`, or `pull` permission for a repository. Repositories inherited through a parent team will also be checked.
 *
 * You can also get information about the specified repository, including what permissions the team grants on it, by passing the following custom [media type](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types/) via the `application/vnd.github.v3.repository+json` accept header.
 *
 * If a team doesn't have permission for the repository, you will receive a `404 Not Found` response status.
 *
 * If the repository is private, you must have at least `read` permission for that repository, and your token must have the `repo` or `admin:org` scope. Otherwise, you will receive a `404 Not Found` response status.
 *
 * > [!NOTE]
 * > You can also specify a team by `org_id` and `team_id` using the route `GET /organizations/{org_id}/team/{team_id}/repos/{owner}/{repo}`.
 *
 * @tag teams
 * @path orgs/:org/teams/:team_slug/repos/:owner/:repo
 * @nestia Generated by Nestia - https://github.com/samchon/nestia
 */
export async function getByOrgAndTeam_slugAndOwnerAndRepo(
  connection: IConnection<getByOrgAndTeam_slugAndOwnerAndRepo.Headers>,
  org: string,
  team_slug: string,
  owner: string,
  repo: string,
): Promise<getByOrgAndTeam_slugAndOwnerAndRepo.Output> {
  return !!connection.simulate
    ? getByOrgAndTeam_slugAndOwnerAndRepo.simulate(
        connection,
        org,
        team_slug,
        owner,
        repo,
      )
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getByOrgAndTeam_slugAndOwnerAndRepo.METADATA,
          path: getByOrgAndTeam_slugAndOwnerAndRepo.path(
            org,
            team_slug,
            owner,
            repo,
          ),
          status: null,
        },
      );
}
export namespace getByOrgAndTeam_slugAndOwnerAndRepo {
  export type Headers = IApiOrgsTeamsRepos.GetHeader;
  export type Output = team_minus_repository;

  export const METADATA = {
    method: "GET",
    path: "/orgs/:org/teams/:team_slug/repos/:owner/:repo",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (
    org: string,
    team_slug: string,
    owner: string,
    repo: string,
  ) =>
    `/orgs/${encodeURIComponent(org ?? "null")}/teams/${encodeURIComponent(team_slug ?? "null")}/repos/${encodeURIComponent(owner ?? "null")}/${encodeURIComponent(repo ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): team_minus_repository => typia.random<team_minus_repository>(g);
  export const simulate = (
    connection: IConnection<getByOrgAndTeam_slugAndOwnerAndRepo.Headers>,
    org: string,
    team_slug: string,
    owner: string,
    repo: string,
  ): Output => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getByOrgAndTeam_slugAndOwnerAndRepo.path(
        org,
        team_slug,
        owner,
        repo,
      ),
      contentType: "application/json",
    });
    try {
      assert.param("org")(() => typia.assert(org));
      assert.param("team_slug")(() => typia.assert(team_slug));
      assert.param("owner")(() => typia.assert(owner));
      assert.param("repo")(() => typia.assert(repo));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}
/**
 * Add or update team repository permissions.
 * To add a repository to a team or update the team's permission on a repository, the authenticated user must have admin access to the repository, and must be able to see the team. The repository must be owned by the organization, or a direct fork of a repository owned by the organization. You will get a `422 Unprocessable Entity` status if you attempt to add a repository to a team that is not owned by the organization. Note that, if you choose not to pass any parameters, you'll need to set `Content-Length` to zero when calling out to this endpoint. For more information, see "[HTTP method](https://docs.github.com/rest/guides/getting-started-with-the-rest-api#http-method)."
 *
 * > [!NOTE]
 * > You can also specify a team by `org_id` and `team_id` using the route `PUT /organizations/{org_id}/team/{team_id}/repos/{owner}/{repo}`.
 *
 * For more information about the permission levels, see "[Repository permission levels for an organization](https://docs.github.com/github/setting-up-and-managing-organizations-and-teams/repository-permission-levels-for-an-organization#permission-levels-for-repositories-owned-by-an-organization)".
 *
 * @tag teams
 * @path orgs/:org/teams/:team_slug/repos/:owner/:repo
 * @nestia Generated by Nestia - https://github.com/samchon/nestia
 */
export async function putByOrgAndTeam_slugAndOwnerAndRepo(
  connection: IConnection<putByOrgAndTeam_slugAndOwnerAndRepo.Headers>,
  org: string,
  team_slug: string,
  owner: string,
  repo: string,
  body: putByOrgAndTeam_slugAndOwnerAndRepo.Input,
): Promise<void> {
  return !!connection.simulate
    ? putByOrgAndTeam_slugAndOwnerAndRepo.simulate(
        connection,
        org,
        team_slug,
        owner,
        repo,
        body,
      )
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putByOrgAndTeam_slugAndOwnerAndRepo.METADATA,
          path: putByOrgAndTeam_slugAndOwnerAndRepo.path(
            org,
            team_slug,
            owner,
            repo,
          ),
          status: null,
        },
        body,
      );
}
export namespace putByOrgAndTeam_slugAndOwnerAndRepo {
  export type Headers = IApiOrgsTeamsRepos.PutHeader;
  export type Input = body;

  export const METADATA = {
    method: "PUT",
    path: "/orgs/:org/teams/:team_slug/repos/:owner/:repo",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (
    org: string,
    team_slug: string,
    owner: string,
    repo: string,
  ) =>
    `/orgs/${encodeURIComponent(org ?? "null")}/teams/${encodeURIComponent(team_slug ?? "null")}/repos/${encodeURIComponent(owner ?? "null")}/${encodeURIComponent(repo ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): void =>
    typia.random<void>(g);
  export const simulate = (
    connection: IConnection<putByOrgAndTeam_slugAndOwnerAndRepo.Headers>,
    org: string,
    team_slug: string,
    owner: string,
    repo: string,
    body: putByOrgAndTeam_slugAndOwnerAndRepo.Input,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putByOrgAndTeam_slugAndOwnerAndRepo.path(
        org,
        team_slug,
        owner,
        repo,
      ),
      contentType: "application/json",
    });
    try {
      assert.param("org")(() => typia.assert(org));
      assert.param("team_slug")(() => typia.assert(team_slug));
      assert.param("owner")(() => typia.assert(owner));
      assert.param("repo")(() => typia.assert(repo));
      assert.body(() => typia.assert(body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}
/**
 * Remove a repository from a team.
 * If the authenticated user is an organization owner or a team maintainer, they can remove any repositories from the team. To remove a repository from a team as an organization member, the authenticated user must have admin access to the repository and must be able to see the team. This does not delete the repository, it just removes it from the team.
 *
 * > [!NOTE]
 * > You can also specify a team by `org_id` and `team_id` using the route `DELETE /organizations/{org_id}/team/{team_id}/repos/{owner}/{repo}`.
 *
 * @tag teams
 * @path orgs/:org/teams/:team_slug/repos/:owner/:repo
 * @nestia Generated by Nestia - https://github.com/samchon/nestia
 */
export async function eraseByOrgAndTeam_slugAndOwnerAndRepo(
  connection: IConnection<eraseByOrgAndTeam_slugAndOwnerAndRepo.Headers>,
  org: string,
  team_slug: string,
  owner: string,
  repo: string,
): Promise<void> {
  return !!connection.simulate
    ? eraseByOrgAndTeam_slugAndOwnerAndRepo.simulate(
        connection,
        org,
        team_slug,
        owner,
        repo,
      )
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseByOrgAndTeam_slugAndOwnerAndRepo.METADATA,
          path: eraseByOrgAndTeam_slugAndOwnerAndRepo.path(
            org,
            team_slug,
            owner,
            repo,
          ),
          status: null,
        },
      );
}
export namespace eraseByOrgAndTeam_slugAndOwnerAndRepo {
  export type Headers = IApiOrgsTeamsRepos.DeleteHeader;

  export const METADATA = {
    method: "DELETE",
    path: "/orgs/:org/teams/:team_slug/repos/:owner/:repo",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (
    org: string,
    team_slug: string,
    owner: string,
    repo: string,
  ) =>
    `/orgs/${encodeURIComponent(org ?? "null")}/teams/${encodeURIComponent(team_slug ?? "null")}/repos/${encodeURIComponent(owner ?? "null")}/${encodeURIComponent(repo ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): void =>
    typia.random<void>(g);
  export const simulate = (
    connection: IConnection<eraseByOrgAndTeam_slugAndOwnerAndRepo.Headers>,
    org: string,
    team_slug: string,
    owner: string,
    repo: string,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseByOrgAndTeam_slugAndOwnerAndRepo.path(
        org,
        team_slug,
        owner,
        repo,
      ),
      contentType: "application/json",
    });
    try {
      assert.param("org")(() => typia.assert(org));
      assert.param("team_slug")(() => typia.assert(team_slug));
      assert.param("owner")(() => typia.assert(owner));
      assert.param("repo")(() => typia.assert(repo));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}
