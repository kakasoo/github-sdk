import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IApiOrgsCopilotBillingSelectedUsers } from "../../../../../structures/IApiOrgsCopilotBillingSelectedUsers";
import { body } from "../../../../../structures/body";
import { response } from "../../../../../structures/response";
/**
 * Add users to the Copilot subscription for an organization.
 * > [!NOTE]
 * > This endpoint is in beta and is subject to change.
 *
 * Purchases a GitHub Copilot seat for each user specified.
 * The organization will be billed accordingly. For more information about Copilot pricing, see "[Pricing for GitHub Copilot](https://docs.github.com/billing/managing-billing-for-github-copilot/about-billing-for-github-copilot#about-billing-for-github-copilot)".
 *
 * Only organization owners can add Copilot seats for their organization members.
 *
 * In order for an admin to use this endpoint, the organization must have a Copilot Business or Enterprise subscription and a configured suggestion matching policy.
 * For more information about setting up a Copilot subscription, see "[Setting up a Copilot subscription for your organization](https://docs.github.com/billing/managing-billing-for-github-copilot/managing-your-github-copilot-subscription-for-your-organization-or-enterprise)".
 * For more information about setting a suggestion matching policy, see "[Configuring suggestion matching policies for GitHub Copilot in your organization](https://docs.github.com/copilot/managing-copilot/managing-policies-for-github-copilot-in-your-organization#configuring-suggestion-matching-policies-for-github-copilot-in-your-organization)".
 *
 * The response will contain the total number of new seats that were created and existing seats that were refreshed.
 *
 * OAuth app tokens and personal access tokens (classic) need either the `manage_billing:copilot` or `admin:org` scopes to use this endpoint.
 *
 * @tag copilot
 * @path orgs/:org/copilot/billing/selected_users
 * @nestia Generated by Nestia - https://github.com/samchon/nestia
 */
export async function postByOrg(
  connection: IConnection<postByOrg.Headers>,
  org: string,
  body: postByOrg.Input,
): Promise<postByOrg.Output> {
  return !!connection.simulate
    ? postByOrg.simulate(connection, org, body)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...postByOrg.METADATA,
          path: postByOrg.path(org),
          status: null,
        },
        body,
      );
}
export namespace postByOrg {
  export type Headers = IApiOrgsCopilotBillingSelectedUsers.PostHeader;
  export type Input = body;
  export type Output = response;

  export const METADATA = {
    method: "POST",
    path: "/orgs/:org/copilot/billing/selected_users",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (org: string) =>
    `/orgs/${encodeURIComponent(org ?? "null")}/copilot/billing/selected_users`;
  export const random = (g?: Partial<typia.IRandomGenerator>): response =>
    typia.random<response>(g);
  export const simulate = (
    connection: IConnection<postByOrg.Headers>,
    org: string,
    body: postByOrg.Input,
  ): Output => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: postByOrg.path(org),
      contentType: "application/json",
    });
    try {
      assert.param("org")(() => typia.assert(org));
      assert.body(() => typia.assert(body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}
/**
 * Remove users from the Copilot subscription for an organization.
 * > [!NOTE]
 * > This endpoint is in beta and is subject to change.
 *
 * Cancels the Copilot seat assignment for each user specified.
 * This will cause the specified users to lose access to GitHub Copilot at the end of the current billing cycle, and the organization will not be billed further for those users.
 *
 * For more information about Copilot pricing, see "[Pricing for GitHub Copilot](https://docs.github.com/billing/managing-billing-for-github-copilot/about-billing-for-github-copilot#about-billing-for-github-copilot)".
 *
 * For more information about disabling access to Copilot Business or Enterprise, see "[Revoking access to GitHub Copilot for specific users in your organization](https://docs.github.com/copilot/managing-copilot/managing-access-for-copilot-in-your-organization#revoking-access-to-github-copilot-for-specific-users-in-your-organization)".
 *
 * Only organization owners can cancel Copilot seats for their organization members.
 *
 * OAuth app tokens and personal access tokens (classic) need either the `manage_billing:copilot` or `admin:org` scopes to use this endpoint.
 *
 * @tag copilot
 * @path orgs/:org/copilot/billing/selected_users
 * @nestia Generated by Nestia - https://github.com/samchon/nestia
 */
export async function eraseByOrg(
  connection: IConnection<eraseByOrg.Headers>,
  org: string,
  body: eraseByOrg.Input,
): Promise<eraseByOrg.Output> {
  return !!connection.simulate
    ? eraseByOrg.simulate(connection, org, body)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseByOrg.METADATA,
          path: eraseByOrg.path(org),
          status: null,
        },
        body,
      );
}
export namespace eraseByOrg {
  export type Headers = IApiOrgsCopilotBillingSelectedUsers.DeleteHeader;
  export type Input = body;
  export type Output = response;

  export const METADATA = {
    method: "DELETE",
    path: "/orgs/:org/copilot/billing/selected_users",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (org: string) =>
    `/orgs/${encodeURIComponent(org ?? "null")}/copilot/billing/selected_users`;
  export const random = (g?: Partial<typia.IRandomGenerator>): response =>
    typia.random<response>(g);
  export const simulate = (
    connection: IConnection<eraseByOrg.Headers>,
    org: string,
    body: eraseByOrg.Input,
  ): Output => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseByOrg.path(org),
      contentType: "application/json",
    });
    try {
      assert.param("org")(() => typia.assert(org));
      assert.body(() => typia.assert(body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}
