import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { IApiUserPackagesVersions } from "../../../../structures/IApiUserPackagesVersions";
import { package_minus_version } from "../../../../structures/package_minus_version";
export * as restore from "./restore";
/**
 * List package versions for a package owned by the authenticated user.
 * Lists package versions for a package owned by the authenticated user.
 *
 * OAuth app tokens and personal access tokens (classic) need the `read:packages` scope to use this endpoint. If the `package_type` belongs to a GitHub Packages registry that only supports repository-scoped permissions, the `repo` scope is also required. For the list of these registries, see "[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages)."
 *
 * @tag packages
 * @path user/packages/:package_type/:package_name/versions
 * @nestia Generated by Nestia - https://github.com/samchon/nestia
 */
export async function getByPackage_typeAndPackage_name(
  connection: IConnection<getByPackage_typeAndPackage_name.Headers>,
  package_type: string,
  package_name: string,
  query: getByPackage_typeAndPackage_name.Query,
): Promise<getByPackage_typeAndPackage_name.Output> {
  return !!connection.simulate
    ? getByPackage_typeAndPackage_name.simulate(
        connection,
        package_type,
        package_name,
        query,
      )
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getByPackage_typeAndPackage_name.METADATA,
          path: getByPackage_typeAndPackage_name.path(
            package_type,
            package_name,
            query,
          ),
          status: null,
        },
      );
}
export namespace getByPackage_typeAndPackage_name {
  export type Headers = IApiUserPackagesVersions.GetHeader;
  export type Query = IApiUserPackagesVersions.GetQuery;
  export type Output = package_minus_version[];

  export const METADATA = {
    method: "GET",
    path: "/user/packages/:package_type/:package_name/versions",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (
    package_type: string,
    package_name: string,
    query: getByPackage_typeAndPackage_name.Query,
  ) => {
    const variables: URLSearchParams = new URLSearchParams();
    for (const [key, value] of Object.entries(query as any))
      if (undefined === value) continue;
      else if (Array.isArray(value))
        value.forEach((elem: any) => variables.append(key, String(elem)));
      else variables.set(key, String(value));
    const location: string = `/user/packages/${encodeURIComponent(package_type ?? "null")}/${encodeURIComponent(package_name ?? "null")}/versions`;
    return 0 === variables.size
      ? location
      : `${location}?${variables.toString()}`;
  };
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): package_minus_version[] => typia.random<package_minus_version[]>(g);
  export const simulate = (
    connection: IConnection<getByPackage_typeAndPackage_name.Headers>,
    package_type: string,
    package_name: string,
    query: getByPackage_typeAndPackage_name.Query,
  ): Output => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getByPackage_typeAndPackage_name.path(
        package_type,
        package_name,
        query,
      ),
      contentType: "application/json",
    });
    try {
      assert.param("package_type")(() => typia.assert(package_type));
      assert.param("package_name")(() => typia.assert(package_name));
      assert.query(() => typia.assert(query));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}
/**
 * Get a package version for the authenticated user.
 * Gets a specific package version for a package owned by the authenticated user.
 *
 * OAuth app tokens and personal access tokens (classic) need the `read:packages` scope to use this endpoint. If the `package_type` belongs to a GitHub Packages registry that only supports repository-scoped permissions, the `repo` scope is also required. For the list of these registries, see "[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages)."
 *
 * @tag packages
 * @path user/packages/:package_type/:package_name/versions/:package_version_id
 * @nestia Generated by Nestia - https://github.com/samchon/nestia
 */
export async function getByPackage_typeAndPackage_nameAndPackage_version_id(
  connection: IConnection<getByPackage_typeAndPackage_nameAndPackage_version_id.Headers>,
  package_type: string,
  package_name: string,
  package_version_id: string,
): Promise<getByPackage_typeAndPackage_nameAndPackage_version_id.Output> {
  return !!connection.simulate
    ? getByPackage_typeAndPackage_nameAndPackage_version_id.simulate(
        connection,
        package_type,
        package_name,
        package_version_id,
      )
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getByPackage_typeAndPackage_nameAndPackage_version_id.METADATA,
          path: getByPackage_typeAndPackage_nameAndPackage_version_id.path(
            package_type,
            package_name,
            package_version_id,
          ),
          status: null,
        },
      );
}
export namespace getByPackage_typeAndPackage_nameAndPackage_version_id {
  export type Headers = IApiUserPackagesVersions.GetHeader;
  export type Output = package_minus_version;

  export const METADATA = {
    method: "GET",
    path: "/user/packages/:package_type/:package_name/versions/:package_version_id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (
    package_type: string,
    package_name: string,
    package_version_id: string,
  ) =>
    `/user/packages/${encodeURIComponent(package_type ?? "null")}/${encodeURIComponent(package_name ?? "null")}/versions/${encodeURIComponent(package_version_id ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): package_minus_version => typia.random<package_minus_version>(g);
  export const simulate = (
    connection: IConnection<getByPackage_typeAndPackage_nameAndPackage_version_id.Headers>,
    package_type: string,
    package_name: string,
    package_version_id: string,
  ): Output => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getByPackage_typeAndPackage_nameAndPackage_version_id.path(
        package_type,
        package_name,
        package_version_id,
      ),
      contentType: "application/json",
    });
    try {
      assert.param("package_type")(() => typia.assert(package_type));
      assert.param("package_name")(() => typia.assert(package_name));
      assert.param("package_version_id")(() =>
        typia.assert(package_version_id),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}
/**
 * Delete a package version for the authenticated user.
 * Deletes a specific package version for a package owned by the authenticated user.  If the package is public and the package version has more than 5,000 downloads, you cannot delete the package version. In this scenario, contact GitHub support for further assistance.
 *
 * The authenticated user must have admin permissions in the organization to use this endpoint.
 *
 * OAuth app tokens and personal access tokens (classic) need the `read:packages` and `delete:packages` scopes to use this endpoint. If the `package_type` belongs to a GitHub Packages registry that only supports repository-scoped permissions, the `repo` scope is also required. For the list of these registries, see "[About permissions for GitHub Packages](https://docs.github.com/packages/learn-github-packages/about-permissions-for-github-packages#permissions-for-repository-scoped-packages)."
 *
 * @tag packages
 * @path user/packages/:package_type/:package_name/versions/:package_version_id
 * @nestia Generated by Nestia - https://github.com/samchon/nestia
 */
export async function eraseByPackage_typeAndPackage_nameAndPackage_version_id(
  connection: IConnection<eraseByPackage_typeAndPackage_nameAndPackage_version_id.Headers>,
  package_type: string,
  package_name: string,
  package_version_id: string,
): Promise<void> {
  return !!connection.simulate
    ? eraseByPackage_typeAndPackage_nameAndPackage_version_id.simulate(
        connection,
        package_type,
        package_name,
        package_version_id,
      )
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseByPackage_typeAndPackage_nameAndPackage_version_id.METADATA,
          path: eraseByPackage_typeAndPackage_nameAndPackage_version_id.path(
            package_type,
            package_name,
            package_version_id,
          ),
          status: null,
        },
      );
}
export namespace eraseByPackage_typeAndPackage_nameAndPackage_version_id {
  export type Headers = IApiUserPackagesVersions.DeleteHeader;

  export const METADATA = {
    method: "DELETE",
    path: "/user/packages/:package_type/:package_name/versions/:package_version_id",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (
    package_type: string,
    package_name: string,
    package_version_id: string,
  ) =>
    `/user/packages/${encodeURIComponent(package_type ?? "null")}/${encodeURIComponent(package_name ?? "null")}/versions/${encodeURIComponent(package_version_id ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): void =>
    typia.random<void>(g);
  export const simulate = (
    connection: IConnection<eraseByPackage_typeAndPackage_nameAndPackage_version_id.Headers>,
    package_type: string,
    package_name: string,
    package_version_id: string,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseByPackage_typeAndPackage_nameAndPackage_version_id.path(
        package_type,
        package_name,
        package_version_id,
      ),
      contentType: "application/json",
    });
    try {
      assert.param("package_type")(() => typia.assert(package_type));
      assert.param("package_name")(() => typia.assert(package_name));
      assert.param("package_version_id")(() =>
        typia.assert(package_version_id),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}
