import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

;
import { IApiReposImportLfs } from "../../../../structures/IApiReposImportLfs";
import { body } from "../../../../structures/body";
import { import } from "../../../../structures/import";
/**
 * Update Git LFS preference.
 * You can import repositories from Subversion, Mercurial, and TFS that include files larger than 100MB. This ability
 * is powered by [Git LFS](https://git-lfs.com).
 *
 * You can learn more about our LFS feature and working with large files [on our help
 * site](https://docs.github.com/repositories/working-with-files/managing-large-files).
 *
 * > [!WARNING]
 * > **Deprecation notice:** Due to very low levels of usage and available alternatives, this endpoint is deprecated and will no longer be available from 00:00 UTC on April 12, 2024. For more details and alternatives, see the [changelog](https://gh.io/source-imports-api-deprecation).
 *
 * @tag migrations
 * @deprecated
 * @path repos/:owner/:repo/import/lfs
 * @nestia Generated by Nestia - https://github.com/samchon/nestia
*/
export async function patchByOwnerAndRepo(connection: IConnection<patchByOwnerAndRepo.Headers>, owner: string, repo: string, body: patchByOwnerAndRepo.Input): Promise<patchByOwnerAndRepo.Output> {
    return !!connection.simulate ? patchByOwnerAndRepo.simulate(connection, owner, repo, body) : PlainFetcher.fetch({
        ...connection,
        headers: {
            ...connection.headers,
            "Content-Type": "application/json"
        }
    }, {
        ...patchByOwnerAndRepo.METADATA,
        path: patchByOwnerAndRepo.path(owner, repo),
        status: null
    }, body);
}
export namespace patchByOwnerAndRepo {
    export type Headers = IApiReposImportLfs.PatchHeader;
    export type Input = body;
    export type Output = import;
    
    ;
    export const METADATA = {
        method: "PATCH",
        path: "/repos/:owner/:repo/import/lfs",
        request: {
            type: "application/json",
            encrypted: false
        },
        response: {
            type: "application/json",
            encrypted: false
        }
    } as const;
    
    ;
    export const path = (owner: string, repo: string) => `/repos/${encodeURIComponent(owner ?? "null")}/${encodeURIComponent(repo ?? "null")}/import/lfs`;
    export const random = (g?: Partial<typia.IRandomGenerator>): import => typia.random<import>(g);
    export const simulate = (connection: IConnection<patchByOwnerAndRepo.Headers>, owner: string, repo: string, body: patchByOwnerAndRepo.Input): Output => {
        const assert = NestiaSimulator.assert({
            method: METADATA.method,
            host: connection.host,
            path: patchByOwnerAndRepo.path(owner, repo),
            contentType: "application/json"
        });
        try {
            assert.param("owner")(() => typia.assert(owner));
            assert.param("repo")(() => typia.assert(repo));
            assert.body(() => typia.assert(body));
        }
        catch (exp) {
            if (!typia.is<HttpError>(exp))
                throw exp;
            return {
                success: false,
                status: exp.status,
                headers: exp.headers,
                data: exp.toJSON().message
            } as any;
        }
        return random("object" === typeof connection.simulate && null !== connection.simulate ? connection.simulate : undefined);
    };
}
