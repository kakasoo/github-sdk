import { HttpError, IConnection } from "@nestia/fetcher";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia from "typia";

import { IApiReposCollaborators } from "../../../structures/IApiReposCollaborators";
import { body } from "../../../structures/body";
import { collaborator } from "../../../structures/collaborator";
import { repository_minus_invitation } from "../../../structures/repository_minus_invitation";

export * as permission from "./permission";
/**
 * List repository collaborators.
 * For organization-owned repositories, the list of collaborators includes outside collaborators, organization members that are direct collaborators, organization members with access through team memberships, organization members with access through default organization permissions, and organization owners.
 * Organization members with write, maintain, or admin privileges on the organization-owned repository can use this endpoint.
 *
 * Team members will include the members of child teams.
 *
 * The authenticated user must have push access to the repository to use this endpoint.
 *
 * OAuth app tokens and personal access tokens (classic) need the `read:org` and `repo` scopes to use this endpoint.
 *
 * @tag repos
 * @path repos/:owner/:repo/collaborators
 * @nestia Generated by Nestia - https://github.com/samchon/nestia
 */
export async function getByOwnerAndRepo(
  connection: IConnection<getByOwnerAndRepo.Headers>,
  owner: string,
  repo: string,
  query: getByOwnerAndRepo.Query,
): Promise<getByOwnerAndRepo.Output> {
  return !!connection.simulate
    ? getByOwnerAndRepo.simulate(connection, owner, repo, query)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getByOwnerAndRepo.METADATA,
          path: getByOwnerAndRepo.path(owner, repo, query),
          status: null,
        },
      );
}
export namespace getByOwnerAndRepo {
  export type Headers = IApiReposCollaborators.GetHeader;
  export type Query = IApiReposCollaborators.GetQuery;
  export type Output = collaborator[];

  export const METADATA = {
    method: "GET",
    path: "/repos/:owner/:repo/collaborators",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (
    owner: string,
    repo: string,
    query: getByOwnerAndRepo.Query,
  ) => {
    const variables: URLSearchParams = new URLSearchParams();
    for (const [key, value] of Object.entries(query as any))
      if (undefined === value) continue;
      else if (Array.isArray(value))
        value.forEach((elem: any) => variables.append(key, String(elem)));
      else variables.set(key, String(value));
    const location: string = `/repos/${encodeURIComponent(owner ?? "null")}/${encodeURIComponent(repo ?? "null")}/collaborators`;
    return 0 === variables.size
      ? location
      : `${location}?${variables.toString()}`;
  };
  export const random = (g?: Partial<typia.IRandomGenerator>): collaborator[] =>
    typia.random<collaborator[]>(g);
  export const simulate = (
    connection: IConnection<getByOwnerAndRepo.Headers>,
    owner: string,
    repo: string,
    query: getByOwnerAndRepo.Query,
  ): Output => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getByOwnerAndRepo.path(owner, repo, query),
      contentType: "application/json",
    });
    try {
      assert.param("owner")(() => typia.assert(owner));
      assert.param("repo")(() => typia.assert(repo));
      assert.query(() => typia.assert(query));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}
/**
 * Check if a user is a repository collaborator.
 * For organization-owned repositories, the list of collaborators includes outside collaborators, organization members that are direct collaborators, organization members with access through team memberships, organization members with access through default organization permissions, and organization owners.
 *
 * Team members will include the members of child teams.
 *
 * The authenticated user must have push access to the repository to use this endpoint.
 *
 * OAuth app tokens and personal access tokens (classic) need the `read:org` and `repo` scopes to use this endpoint.
 *
 * @tag repos
 * @path repos/:owner/:repo/collaborators/:username
 * @nestia Generated by Nestia - https://github.com/samchon/nestia
 */
export async function getByOwnerAndRepoAndUsername(
  connection: IConnection<getByOwnerAndRepoAndUsername.Headers>,
  owner: string,
  repo: string,
  username: string,
): Promise<void> {
  return !!connection.simulate
    ? getByOwnerAndRepoAndUsername.simulate(connection, owner, repo, username)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getByOwnerAndRepoAndUsername.METADATA,
          path: getByOwnerAndRepoAndUsername.path(owner, repo, username),
          status: null,
        },
      );
}
export namespace getByOwnerAndRepoAndUsername {
  export type Headers = IApiReposCollaborators.GetHeader;

  export const METADATA = {
    method: "GET",
    path: "/repos/:owner/:repo/collaborators/:username",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (owner: string, repo: string, username: string) =>
    `/repos/${encodeURIComponent(owner ?? "null")}/${encodeURIComponent(repo ?? "null")}/collaborators/${encodeURIComponent(username ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): void =>
    typia.random<void>(g);
  export const simulate = (
    connection: IConnection<getByOwnerAndRepoAndUsername.Headers>,
    owner: string,
    repo: string,
    username: string,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getByOwnerAndRepoAndUsername.path(owner, repo, username),
      contentType: "application/json",
    });
    try {
      assert.param("owner")(() => typia.assert(owner));
      assert.param("repo")(() => typia.assert(repo));
      assert.param("username")(() => typia.assert(username));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}
/**
 * Add a repository collaborator.
 * This endpoint triggers [notifications](https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. For more information, see "[Rate limits for the API](https://docs.github.com/rest/using-the-rest-api/rate-limits-for-the-rest-api#about-secondary-rate-limits)" and "[Best practices for using the REST API](https://docs.github.com/rest/guides/best-practices-for-using-the-rest-api)."
 *
 * Adding an outside collaborator may be restricted by enterprise administrators. For more information, see "[Enforcing repository management policies in your enterprise](https://docs.github.com/admin/policies/enforcing-policies-for-your-enterprise/enforcing-repository-management-policies-in-your-enterprise#enforcing-a-policy-for-inviting-outside-collaborators-to-repositories)."
 *
 * For more information on permission levels, see "[Repository permission levels for an organization](https://docs.github.com/github/setting-up-and-managing-organizations-and-teams/repository-permission-levels-for-an-organization#permission-levels-for-repositories-owned-by-an-organization)". There are restrictions on which permissions can be granted to organization members when an organization base role is in place. In this case, the permission being given must be equal to or higher than the org base permission. Otherwise, the request will fail with:
 *
 * ```
 * Cannot assign {member} permission of {role name}
 * ```
 *
 * Note that, if you choose not to pass any parameters, you'll need to set `Content-Length` to zero when calling out to this endpoint. For more information, see "[HTTP method](https://docs.github.com/rest/guides/getting-started-with-the-rest-api#http-method)."
 *
 * The invitee will receive a notification that they have been invited to the repository, which they must accept or decline. They may do this via the notifications page, the email they receive, or by using the [API](https://docs.github.com/rest/collaborators/invitations).
 *
 * **Updating an existing collaborator's permission level**
 *
 * The endpoint can also be used to change the permissions of an existing collaborator without first removing and re-adding the collaborator. To change the permissions, use the same endpoint and pass a different `permission` parameter. The response will be a `204`, with no other indication that the permission level changed.
 *
 * **Rate limits**
 *
 * You are limited to sending 50 invitations to a repository per 24 hour period. Note there is no limit if you are inviting organization members to an organization repository.
 *
 * @tag repos
 * @path repos/:owner/:repo/collaborators/:username
 * @nestia Generated by Nestia - https://github.com/samchon/nestia
 */
export async function putByOwnerAndRepoAndUsername(
  connection: IConnection<putByOwnerAndRepoAndUsername.Headers>,
  owner: string,
  repo: string,
  username: string,
  body: putByOwnerAndRepoAndUsername.Input,
): Promise<putByOwnerAndRepoAndUsername.Output> {
  return !!connection.simulate
    ? putByOwnerAndRepoAndUsername.simulate(
        connection,
        owner,
        repo,
        username,
        body,
      )
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...putByOwnerAndRepoAndUsername.METADATA,
          path: putByOwnerAndRepoAndUsername.path(owner, repo, username),
          status: null,
        },
        body,
      );
}
export namespace putByOwnerAndRepoAndUsername {
  export type Headers = IApiReposCollaborators.PutHeader;
  export type Input = body;
  export type Output = repository_minus_invitation;

  export const METADATA = {
    method: "PUT",
    path: "/repos/:owner/:repo/collaborators/:username",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (owner: string, repo: string, username: string) =>
    `/repos/${encodeURIComponent(owner ?? "null")}/${encodeURIComponent(repo ?? "null")}/collaborators/${encodeURIComponent(username ?? "null")}`;
  export const random = (
    g?: Partial<typia.IRandomGenerator>,
  ): repository_minus_invitation =>
    typia.random<repository_minus_invitation>(g);
  export const simulate = (
    connection: IConnection<putByOwnerAndRepoAndUsername.Headers>,
    owner: string,
    repo: string,
    username: string,
    body: putByOwnerAndRepoAndUsername.Input,
  ): Output => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: putByOwnerAndRepoAndUsername.path(owner, repo, username),
      contentType: "application/json",
    });
    try {
      assert.param("owner")(() => typia.assert(owner));
      assert.param("repo")(() => typia.assert(repo));
      assert.param("username")(() => typia.assert(username));
      assert.body(() => typia.assert(body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}
/**
 * Remove a repository collaborator.
 * Removes a collaborator from a repository.
 *
 * To use this endpoint, the authenticated user must either be an administrator of the repository or target themselves for removal.
 *
 * This endpoint also:
 * - Cancels any outstanding invitations
 * - Unasigns the user from any issues
 * - Removes access to organization projects if the user is not an organization member and is not a collaborator on any other organization repositories.
 * - Unstars the repository
 * - Updates access permissions to packages
 *
 * Removing a user as a collaborator has the following effects on forks:
 * - If the user had access to a fork through their membership to this repository, the user will also be removed from the fork.
 * - If the user had their own fork of the repository, the fork will be deleted.
 * - If the user still has read access to the repository, open pull requests by this user from a fork will be denied.
 *
 * > [!NOTE]
 * > A user can still have access to the repository through organization permissions like base repository permissions.
 *
 * Although the API responds immediately, the additional permission updates might take some extra time to complete in the background.
 *
 * For more information on fork permissions, see "[About permissions and visibility of forks](https://docs.github.com/pull-requests/collaborating-with-pull-requests/working-with-forks/about-permissions-and-visibility-of-forks)".
 *
 * @tag repos
 * @path repos/:owner/:repo/collaborators/:username
 * @nestia Generated by Nestia - https://github.com/samchon/nestia
 */
export async function eraseByOwnerAndRepoAndUsername(
  connection: IConnection<eraseByOwnerAndRepoAndUsername.Headers>,
  owner: string,
  repo: string,
  username: string,
): Promise<void> {
  return !!connection.simulate
    ? eraseByOwnerAndRepoAndUsername.simulate(connection, owner, repo, username)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseByOwnerAndRepoAndUsername.METADATA,
          path: eraseByOwnerAndRepoAndUsername.path(owner, repo, username),
          status: null,
        },
      );
}
export namespace eraseByOwnerAndRepoAndUsername {
  export type Headers = IApiReposCollaborators.DeleteHeader;

  export const METADATA = {
    method: "DELETE",
    path: "/repos/:owner/:repo/collaborators/:username",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (owner: string, repo: string, username: string) =>
    `/repos/${encodeURIComponent(owner ?? "null")}/${encodeURIComponent(repo ?? "null")}/collaborators/${encodeURIComponent(username ?? "null")}`;
  export const random = (g?: Partial<typia.IRandomGenerator>): void =>
    typia.random<void>(g);
  export const simulate = (
    connection: IConnection<eraseByOwnerAndRepoAndUsername.Headers>,
    owner: string,
    repo: string,
    username: string,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseByOwnerAndRepoAndUsername.path(owner, repo, username),
      contentType: "application/json",
    });
    try {
      assert.param("owner")(() => typia.assert(owner));
      assert.param("repo")(() => typia.assert(repo));
      assert.param("username")(() => typia.assert(username));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random(
      "object" === typeof connection.simulate && null !== connection.simulate
        ? connection.simulate
        : undefined,
    );
  };
}
